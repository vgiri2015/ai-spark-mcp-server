"""
MCP Client implementation for Spark optimization.
"""
import asyncio
import json
from typing import Dict, List, Any, Optional

class SparkMCPClient:
    """MCP client for interacting with Spark optimization server."""
    
    def __init__(self, host: str = "localhost", port: int = 8080):
        self.host = host
        self.port = port
        self._reader: Optional[asyncio.StreamReader] = None
        self._writer: Optional[asyncio.StreamWriter] = None

    async def connect(self):
        """Connect to the MCP server."""
        self._reader, self._writer = await asyncio.open_connection(
            self.host, self.port
        )

    async def close(self):
        """Close the connection to the MCP server."""
        if self._writer:
            self._writer.close()
            await self._writer.wait_closed()

    async def list_tools(self) -> List[Dict[str, Any]]:
        """List available tools from the MCP server."""
        response = await self._send_request({
            "method": "tools/list"
        })
        return response["tools"]

    async def optimize_spark_code(self, code: str, optimization_level: str = "advanced", save_to_file: bool = True) -> str:
        """Optimize Spark code using the MCP server.
        
        Args:
            code: The Spark code to optimize
            optimization_level: Level of optimization ("basic" or "advanced")
            save_to_file: If True, saves optimized code to examples/optimized_spark_example.py
            
        Returns:
            The optimized code as a string
        """
        response = await self._send_request({
            "method": "tools/call",
            "params": {
                "name": "optimize_spark_code",
                "arguments": {
                    "code": code,
                    "optimization_level": optimization_level
                }
            }
        })
        
        optimized_code = response["content"][0]["text"]
        
        if save_to_file:
            # Extract just the code block from the response
            code_block = ""
            in_code_block = False
            for line in optimized_code.split("\n"):
                if line.startswith("```python"):
                    in_code_block = True
                    continue
                elif line.startswith("```"):
                    in_code_block = False
                    continue
                elif in_code_block:
                    code_block += line + "\n"
            
            # Save to file
            import os
            examples_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "examples")
            output_file = os.path.join(examples_dir, "optimized_spark_example.py")
            
            docstring = '"""\nOptimized PySpark code generated by Spark MCP.\n"""\n'
            with open(output_file, "w") as f:
                f.write(docstring)
                f.write(code_block)
            
            print(f"\nOptimized code saved to: {output_file}")
        
        return optimized_code

    async def analyze_performance(self, original_code: str, optimized_code: str) -> Dict[str, Any]:
        """Analyze performance between original and optimized code."""
        response = await self._send_request({
            "method": "tools/call",
            "params": {
                "name": "analyze_performance",
                "arguments": {
                    "original_code": original_code,
                    "optimized_code": optimized_code
                }
            }
        })
        return response["content"][0]

    async def _send_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Send a request to the MCP server and get the response."""
        if not self._writer or not self._reader:
            raise RuntimeError("Not connected to MCP server")

        self._writer.write(json.dumps(request).encode() + b"\n")
        await self._writer.drain()

        data = await self._reader.readline()
        if not data:
            raise ConnectionError("Connection closed by server")

        return json.loads(data)
